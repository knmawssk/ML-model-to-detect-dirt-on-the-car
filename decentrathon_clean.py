# -*- coding: utf-8 -*-
"""Decentrathon clean

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FqKuy618Hsu40S2j3Kx6wwevp_asl6Nw
"""

!pip install ultralytics roboflow albumentations tqdm pyyaml

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="")
project = rf.workspace("fall-on7ds").project("clean-or-dirty-dataset-b4kgw")
version = project.version(1)
dataset = version.download("yolov8", location='new_dataset')

!mv /content/new_dataset/valid /content/new_dataset/val

!python /content/pipeline.py \
  --mode full \
  --data-source local \
  --dataset-dir /content/new_dataset \
  --augmented-dir /content/newdatasetresults \
  --num-aug 2 \
  --model-path yolov8s.pt \
  --epochs 10 \
  --batch-size 4 \
  --class-names dirty clean \
  --device 0

!pip install ultralytics opencv-python

from ultralytics import YOLO
from collections import Counter
from IPython.display import Image, display
import cv2
import os

# Load your trained model
model = YOLO('/content/best.pt')

# Path to an image you want to test
image_path = '/content/istockphoto-1477260992-612x612.jpg'  # replace with real image path

# Run prediction
results = model.predict(source=image_path, conf=0.3)

# Get detected class indices
classes = results[0].boxes.cls.tolist()
counts = Counter(classes)

# Class indices based on dataset.yaml
dirt_count = counts.get(1, 0)
clean_count = counts.get(0, 0)

# --- Draw bounding boxes ---
img = cv2.imread(image_path)

for box, cls in zip(results[0].boxes.xyxy, results[0].boxes.cls):
    x1, y1, x2, y2 = map(int, box)
    if int(cls) == 1:
        color = (0, 0, 255)  # красный
        label = "dirt"
    elif int(cls) == 0:
        color = (0, 255, 0)  # зеленый
        label = "clean"
    else:
        continue
    cv2.rectangle(img, (x1, y1), (x2, y2), color, 2)
    cv2.putText(img, label, (x1, y1 - 5),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

# Save and show image
cv2.imwrite("predicted_people.jpg", img)
display(Image(filename="predicted_people.jpg"))

# Decide based on detection
if dirt_count > 0:
    print("The car is dirty!")
else:
    print("The car is clean")

!pip install ultralytics opencv-python

from ultralytics import YOLO
from collections import Counter
from IPython.display import Image, display
import cv2
import os

# Load your trained model
model = YOLO('/content/best.pt')

# Папка с изображениями
image_folder = '/content/new_dataset/test/images'

# Создаем папку для результатов
output_folder = '/content/predicted_images2'
os.makedirs(output_folder, exist_ok=True)

# Проходим по всем изображениям в папке
for filename in os.listdir(image_folder):
    if filename.lower().endswith(('.jpg', '.jpeg', '.png')):
        image_path = os.path.join(image_folder, filename)
        results = model.predict(source=image_path, conf=0.3)

        # Получаем классы детекций
        classes = results[0].boxes.cls.tolist()
        counts = Counter(classes)

        dirt_count = counts.get(1, 0)
        clean_count = counts.get(0, 0)

        # Загружаем изображение для отрисовки
        img = cv2.imread(image_path)
        for box, cls in zip(results[0].boxes.xyxy, results[0].boxes.cls):
            x1, y1, x2, y2 = map(int, box)
            if int(cls) == 1:  # dirt
                color = (0, 0, 255)
                label = "dirt"
            elif int(cls) == 0:  # clean
                color = (0, 255, 0)
                label = "clean"
            else:
                continue
                cv2.rectangle(img, (x1, y1), (x2, y2), color, 2)
                cv2.putText(img, label, (x1, y1 - 5),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

        # Сохраняем изображение
        save_path = os.path.join(output_folder, filename)
        cv2.imwrite(save_path, img)

        # Выводим результат
        if dirt_count > 0:
            print(f"{filename}: The car is dirty!")
        else:
            print(f"{filename}: The car is clean")

from ultralytics import YOLO
import pandas as pd
import os

# Загружаем обученную модель
model = YOLO('/content/best.pt')

# Путь к data.yaml (замени на свой реальный путь!)
data_yaml = "/content/new_dataset/data.yaml"

# Оценка модели на test-сплите
metrics = model.val(data=data_yaml, split='test')

# Выводим метрики
print("Evaluation Metrics:")
print(f"  Precision: {metrics.box.mp:.4f}")
print(f"  Recall: {metrics.box.mr:.4f}")
print(f"  mAP50: {metrics.box.map50:.4f}")
print(f"  mAP50-95: {metrics.box.map:.4f}")

!zip -r /content/predicted_images2.zip /content/predicted_images2

